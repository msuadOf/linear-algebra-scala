## 前言
出于考研手痒，又正好线代差不多看完了，想着用scala写个线代的库玩玩。（刚复习的时候用C写了一个，但是不是很贴近我的需求，实现起来也麻烦）
## 需求
- 写起来方便
- 支持精确的分数运算（好用来对答案啊，不然每次对答案验算一遍老费时间了）
。。。有就再加吧
## 分析
为什么不用现成的库：
首先分数运算就没找到想用的，好用的
其次大多数的矩阵库多少都会支持特征值啊这些的，所以都是相似逼近结的特征值，不精确。。。
本来想用numpy，然后照着一堆x.xe-xxx看了半天，看晕了，而且相似变换矩阵Q还特么相似对角化了，pass
所以一怒之下自己干
仓库
先上链接：
[GitHub - msuadOf/linear-algebra-scala](https://github.com/msuadOf/linear-algebra-scala)
## Feature
支持基于Int的分数Fraction类，没做泛型，目前想法就是学习验算用
Fraction类做了配套的Implicit隐式转换，看起来Fraction更像原生支持
针对Matrix相关基础线性操作做了支持，加减乘除，求逆求伴随求行列式
Implicit也做了Matrix相关的支持，能Matrix((x,x),(x,x))这样无感地书写矩阵
## TODO
说了Feature那说点畅想吧
[ ] - REPL中使用这个库
[ ] - 特征值、特征向量
[ ] - 矩阵相似
[ ] - 向量的支持：分块矩阵、向量等价
[ ] - 之前有看有人numpy手搓神经网络，我想看看我这能不能拿来蹂躏电脑
## 代码
大概三四天的样子，零零碎碎写了线代前四章也就是矩阵的一些基本运算，计算量大的基本都在了
Scala还是一门很好的语言的，写起来比C/C++舒服，不过也有可能是C++功底太差（）
### 继承链
自顶向下介绍
MatrixLike(trait)->Matrix->SquareMatrix | AugmentedMatrix
#### Fraction类
这个Class最核心的是两个Int，一个分子一个分母
以下是用gpt苦力写的测试样例，一个大致使用方法，虽然我觉得这个项目的意义在于小，且可以自己修改就是了。。。
```scala
List(
(1.F).toString -> "1",
(-2.F).toString -> "-2",
(1.F / 2.F).toString -> "(1/2)",
("-1/2".F == "1/-2".F) -> true,
("-1/2".F == "-1/2".F) -> true,
("-1/2".F == "1/2".F) -> false,

((3 === 3.F)) -> true,
((2 + 3.F) == 5.F) -> true,  
((2 - 3.F) == (-1.F)) -> true,
((2 * 3.F) == 6.F) -> true,
((2 / 3.F) == "2/3".F) -> true

(("1/2".F * "1/4".F).toString) -> "(1/8)",
(("1/2".F / "1/4".F).toString) -> "2",
(("1/2".F.abs).toString) -> "(1/2)",
(("1/2".F.negate).toString) -> "(-1/2)",
(("1/2".F.inv).toString) -> "2", 
(("1/2".F.min("3/4".F)).toString) -> "(1/2)",
(("1/2".F.max("3/4".F)).toString) -> "(3/4)"
)
```
#### Matrix类
上样例，gpt老哥写的
```scala
List(
    Matrix((-1.F / 2, 2), (3, 4), (5, 6)) -> Matrix((-1.F / 2, 2), (3, 4), (5, 6)),
    (Matrix((-1.F / 2, 2), (3, 4), (5, 6)).T) ->
      Matrix(((-1.F / 2), 3, 5), (2, 4, 6)),
    ((Matrix((-1.F / 2, 2), (3, 4), (5, 6)) + Matrix((1, 0), (0, 1), (0, 0)))) ->
      Matrix(((1.F / 2), 2), (3, 5), (5, 6)),
    ((Matrix((-1.F / 2, 2), (3, 4), (5, 6)) * 2.F)) ->
      Matrix((-1.F, 4), (6, 8), (10, 12)),
    ((Matrix((-1.F / 2, 2), (3, 4)) * Matrix((1, 0), (0, 1)))) ->
      Matrix((-1.F / 2, 2), (3, 4)) // 确保矩阵乘法逻辑正确
  )
```
选自660的一个无辜矩阵
```scala
val n = Matrix(
    (1, 2, 3, 1),
    (2, -1, 1, -3),
    (1, 0, 1, -1),
  )

  println(n.T)
  println(n.r)
  println(n.toReducedRowEchelonForm)
  println(p.adjoint )
/*
Matrix[4x3]:
[ 1,  2,  1]
[ 2, -1,  0]
[ 3,  1,  1]
[ 1, -3, -1]
2

Matrix[3x4]:
[ 1,  0,  1, -1]
[ 0,  1,  1,  1]
[ 0,  0,  0,  0]

SquareMatrix[2x2]:
[     4,     -2]
[    -3, (-1/2)]
*/
```
时间不早了，先写这么多了，后面有空接着写吧